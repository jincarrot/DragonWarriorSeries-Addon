"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveCache = exports.isCached = exports.clearCache = exports.registerCachedTask = void 0;
const package_deps_hash_1 = require("@rushstack/package-deps-hash");
const option_1 = require("./option");
const resolve_1 = require("./resolve");
const fs = require("fs-extra");
const path = require("path");
const logger_1 = require("./logger");
const findDependents_1 = require("./package/findDependents");
const findGitRoot_1 = require("./package/findGitRoot");
const child_process_1 = require("child_process");
const cachedTask = [];
const CacheFileName = 'package-deps.json';
function registerCachedTask(taskName) {
    cachedTask.push(taskName);
}
exports.registerCachedTask = registerCachedTask;
function clearCache() {
    const cachePath = getCachePath();
    const cacheFile = path.join(cachePath, CacheFileName);
    if (fs.existsSync(cacheFile)) {
        fs.removeSync(cacheFile);
    }
}
exports.clearCache = clearCache;
function isCached(taskName) {
    if (cachedTask.indexOf(taskName) < 0) {
        return false;
    }
    const currentHash = getHash(taskName);
    const cachePath = getCachePath();
    const cacheFile = path.join(cachePath, CacheFileName);
    if (!fs.existsSync(cacheFile)) {
        return false;
    }
    let shouldCache = false;
    try {
        const cachedHash = JSON.parse(fs.readFileSync(path.join(cachePath, CacheFileName)).toString());
        // TODO: make a more robust comparison
        shouldCache = JSON.stringify(currentHash) === JSON.stringify(cachedHash);
    }
    catch (e) {
        logger_1.logger.warn('Invalid package-deps.json detected');
    }
    return shouldCache;
}
exports.isCached = isCached;
function saveCache(taskName) {
    if (cachedTask.indexOf(taskName) < 0) {
        return;
    }
    const cachePath = getCachePath();
    if (!fs.pathExistsSync(cachePath)) {
        fs.mkdirpSync(cachePath);
    }
    const cacheHash = getHash(taskName);
    if (cacheHash) {
        fs.writeFileSync(path.join(cachePath, 'package-deps.json'), JSON.stringify(cacheHash, null, 2));
    }
}
exports.saveCache = saveCache;
function getPackageRootPath() {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const packageJsonFilePath = (0, resolve_1.resolveCwd)('package.json');
    return path.dirname(packageJsonFilePath);
}
function getCachePath() {
    const rootPath = getPackageRootPath();
    return path.join(rootPath, 'node_modules/.just');
}
function getLockFileHashes() {
    const results = {};
    const lockFiles = ['shrinkwrap.yml', 'package-lock.json', 'yarn.lock', 'pnpmfile.js'];
    const gitRoot = (0, findGitRoot_1.findGitRoot)();
    const lsFileResults = (0, child_process_1.spawnSync)('git', ['ls-files', ...lockFiles], { cwd: gitRoot });
    if (lsFileResults.status !== 0) {
        return {};
    }
    const foundLockFiles = lsFileResults.stdout
        .toString()
        .split(/\n/)
        .map(l => l.trim());
    const hashResults = (0, child_process_1.spawnSync)('git', ['hash-object', ...foundLockFiles], { cwd: gitRoot });
    if (hashResults.status !== 0) {
        return {};
    }
    const hashes = hashResults.stdout
        .toString()
        .split(/\n/)
        .map(l => l.trim());
    foundLockFiles.forEach((foundLockFile, index) => {
        results[foundLockFile] = hashes[index];
    });
    return results;
}
function getHash(taskName) {
    (0, logger_1.mark)('cache:getHash');
    const { ...args } = (0, option_1.argv)();
    const packageRootPath = getPackageRootPath();
    const packageDeps = {
        ...Object.fromEntries((0, package_deps_hash_1.getPackageDeps)(packageRootPath)),
        ...getLockFileHashes(),
    };
    const hash = {
        args,
        taskName,
        hash: packageDeps,
        dependentHashTimestamps: getDependentHashTimestamps(),
    };
    logger_1.logger.perf('cache:getHash');
    return hash;
}
function getDependentHashTimestamps() {
    (0, logger_1.mark)('cache:getDependentHashTimestamps');
    const dependentPkgPaths = (0, findDependents_1.findDependents)();
    const timestampsByPackage = {};
    for (const pkgDepInfo of dependentPkgPaths) {
        const pkgPath = pkgDepInfo.path;
        const depHashFile = path.join(pkgPath, 'node_modules/.just', CacheFileName);
        const depPackageJson = JSON.parse(fs.readFileSync(path.join(pkgPath, 'package.json'), 'utf-8'));
        if (fs.existsSync(depHashFile)) {
            const stat = fs.statSync(depHashFile);
            timestampsByPackage[pkgDepInfo.name] = stat.mtimeMs;
        }
        else if (depPackageJson.scripts) {
            // always updated if no hash file is found for dependants
            timestampsByPackage[pkgDepInfo.name] = new Date().getTime();
        }
    }
    logger_1.logger.perf('cache:getDependentHashTimestamps');
    return timestampsByPackage;
}
